commands:

# ======== ACTIVE WINDOW / FOCUS / TYPE ========
- id: CMD_GET_ACTIVE_WINDOW_TITLE
  intents: ["какое активное окно", "активное окно", "active window title", "проверь активное окно"]
  description_short: "Показывает заголовок активного окна."
  execute:
    lang: python
    script: |
      import pygetwindow as gw
      win = gw.getActiveWindow()
      print("ACTIVE_WINDOW:", win.title if win else "NONE")
  verify:
    lang: python
    script: |
      import pygetwindow as gw
      win = gw.getActiveWindow()
      print("OK" if win else "NONE")
  success:
    type: custom

- id: CMD_VERIFY_ACTIVE_WINDOW_CONTAINS
  intents: ["проверь что активное окно содержит *", "active window contains *"]
  description_short: "Проверяет что заголовок активного окна содержит текст."
  params:
    - name: text
      from_user: true
  execute:
    lang: python
    script: |
      import pygetwindow as gw
      target = "{{text}}".lower()
      win = gw.getActiveWindow()
      title = (win.title if win else "").lower()
      if target in title:
        print("OK: active window contains", target)
      else:
        raise RuntimeError(f"Active window mismatch: '{title}' not contains '{target}'")
  verify:
    lang: python
    script: |
      print("OK")
  success:
    type: custom

- id: CMD_TYPE_ACTIVE_TEXT
  intents: ["напиши *", "впиши *", "введи *", "пиши *", "в активное поле *"]
  description_short: "Печатает текст в активное поле/окно."
  params:
    - name: text
      from_user: true
  execute:
    lang: python
    script: |
      import time
      import pyautogui
      import pygetwindow as gw
      text = "{{text}}"
      win = gw.getActiveWindow()
      if not win:
        raise RuntimeError("No active window")
      time.sleep(0.15)
      pyautogui.typewrite(text, interval=0.01)
      print("OK: typed")
  verify:
    lang: python
    script: |
      import pygetwindow as gw
      win = gw.getActiveWindow()
      print("OK: active_window=" + (win.title if win else "NONE"))
  success:
    type: custom

- id: CMD_PRESS_ENTER
  intents: ["нажми enter", "enter", "нажми ввод"]
  description_short: "Нажимает Enter."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.press("enter")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_PRESS_ESC
  intents: ["нажми escape", "esc", "закрой меню"]
  description_short: "Нажимает Escape."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.press("esc")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

# ======== CLIPBOARD ========
- id: CMD_COPY
  intents: ["копируй", "скопируй", "копировать"]
  description_short: "Ctrl+C (копировать выделенное)."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","c")
      print("OK: copy")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_PASTE
  intents: ["вставь", "вставить", "paste"]
  description_short: "Ctrl+V (вставить)."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","v")
      print("OK: paste")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_CUT
  intents: ["вырежи", "вырезать", "cut"]
  description_short: "Ctrl+X (вырезать)."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","x")
      print("OK: cut")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_SELECT_ALL
  intents: ["выдели все", "выделить все", "select all"]
  description_short: "Ctrl+A (выделить всё)."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","a")
      print("OK: select all")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_PASTE_TEXT
  intents: ["вставь текст *", "вклей *"]
  description_short: "Копирует текст в буфер и вставляет (стабильно для длинного)."
  params:
    - name: text
      from_user: true
  execute:
    lang: python
    script: |
      import time
      import pyautogui
      import pyperclip
      text = "{{text}}"
      pyperclip.copy(text)
      time.sleep(0.05)
      pyautogui.hotkey("ctrl","v")
      print("OK: pasted text")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

# ======== WINDOW MANAGEMENT ========
- id: CMD_CLOSE_ACTIVE_WINDOW
  intents: ["закрой окно", "закрой активное окно", "закрой текущее"]
  description_short: "Alt+F4 закрывает активное окно."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("alt","f4")
      print("OK: alt+f4")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_MINIMIZE_ACTIVE_WINDOW
  intents: ["сверни окно", "сверни активное"]
  description_short: "Win+Down сворачивает активное окно."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("win","down")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_MAXIMIZE_ACTIVE_WINDOW
  intents: ["разверни окно", "на весь экран окно", "увеличь окно"]
  description_short: "Win+Up разворачивает активное окно."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("win","up")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_SHOW_DESKTOP
  intents: ["покажи рабочий стол", "сверни все окна", "win d"]
  description_short: "Win+D показать рабочий стол."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("win","d")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_ALT_TAB
  intents: ["переключи окно", "следующее окно", "alt tab"]
  description_short: "Alt+Tab переключает окно."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("alt","tab")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

# ======== APPS ========
- id: CMD_OPEN_NOTEPAD
  intents: ["открой блокнот", "запусти блокнот", "notepad"]
  description_short: "Открывает Блокнот и переводит фокус в окно (чтобы печать работала)."
  execute:
    lang: python
    script: |
      import time
      import subprocess
      import pyautogui
      import pygetwindow as gw

      subprocess.Popen(["notepad.exe"])
      time.sleep(0.6)

      wins = []
      try:
        wins += gw.getWindowsWithTitle("Блокнот")
      except Exception:
        pass
      try:
        wins += gw.getWindowsWithTitle("Notepad")
      except Exception:
        pass

      if wins:
        w = wins[0]
        try:
          w.restore()
        except Exception:
          pass
        try:
          w.activate()
        except Exception:
          pass
        time.sleep(0.2)
        # Клик в центр, чтобы курсор точно оказался в поле ввода
        try:
          x = w.left + w.width // 2
          y = w.top + w.height // 2
          pyautogui.click(x, y)
        except Exception:
          pass

      print("OK: notepad opened")
  verify:
    lang: python
    script: |
      import psutil
      names = []
      for p in psutil.process_iter(["name"]):
        try:
          names.append((p.info.get("name") or "").lower())
        except Exception:
          pass
      if any(n in ("notepad.exe", "notepad") for n in names):
        print("OK")
      else:
        raise RuntimeError("notepad not running")
  success:
    type: custom
  state_update:
    active_app: "notepad"

- id: CMD_FOCUS_NOTEPAD
  intents: ["сфокусируй блокнот", "переключись на блокнот", "focus notepad"]
  description_short: "Активирует окно Блокнота (если уже открыто)."
  execute:
    lang: python
    script: |
      import time
      import pyautogui
      import pygetwindow as gw

      wins = []
      try:
        wins += gw.getWindowsWithTitle("Блокнот")
      except Exception:
        pass
      try:
        wins += gw.getWindowsWithTitle("Notepad")
      except Exception:
        pass

      if not wins:
        raise RuntimeError("Notepad window not found")
      w = wins[0]
      try:
        w.restore()
      except Exception:
        pass
      w.activate()
      time.sleep(0.2)
      # клик по центру, чтобы курсор был в редакторе
      x = w.left + w.width // 2
      y = w.top + w.height // 2
      pyautogui.click(x, y)
      print("OK: focused notepad")
  verify:
    lang: python
    script: |
      import pygetwindow as gw
      w = gw.getActiveWindow()
      title = (w.title if w else "").lower()
      if "блокнот" in title or "notepad" in title:
        print("OK")
      else:
        raise RuntimeError("Notepad is not active")
  success:
    type: custom
  state_update:
    active_app: "notepad"

- id: CMD_TYPE_IN_NOTEPAD
  intents: ["в блокноте *", "в блокнот *", "в блокноте напиши *", "в блокнот напиши *"]
  description_short: "Пишет текст именно в Блокнот (активирует окно и печатает)."
  params:
    - name: text
      from_user: true
  execute:
    lang: python
    script: |
      import time
      import pyautogui
      import pygetwindow as gw

      text = "{{text}}"

      wins = []
      try:
        wins += gw.getWindowsWithTitle("Блокнот")
      except Exception:
        pass
      try:
        wins += gw.getWindowsWithTitle("Notepad")
      except Exception:
        pass

      if not wins:
        raise RuntimeError("Notepad window not found")

      w = wins[0]
      try:
        w.restore()
      except Exception:
        pass
      try:
        w.activate()
      except Exception:
        pass

      time.sleep(0.2)
      # клик в центр редактора
      x = w.left + w.width // 2
      y = w.top + w.height // 2
      pyautogui.click(x, y)
      time.sleep(0.05)
      pyautogui.typewrite(text, interval=0.01)
      print("OK: typed into notepad")
  verify:
    lang: python
    script: |
      import pygetwindow as gw
      w = gw.getActiveWindow()
      title = (w.title if w else "").lower()
      if "блокнот" in title or "notepad" in title:
        print("OK")
      else:
        raise RuntimeError("Notepad is not active")
  success:
    type: custom
  state_update:
    active_app: "notepad"


- id: CMD_CLOSE_NOTEPAD
  intents: ["закрой блокнот", "убей блокнот"]
  description_short: "Закрывает Блокнот."
  execute: {lang: powershell, script: "Stop-Process -Name notepad -ErrorAction SilentlyContinue"}
  verify: {lang: powershell, script: "if (Get-Process notepad -ErrorAction SilentlyContinue) { exit 1 } else { 'OK' }"}
  success: {type: custom}

- id: CMD_OPEN_CALCULATOR
  intents: ["открой калькулятор", "запусти калькулятор", "calculator"]
  description_short: "Открывает калькулятор."
  execute: {lang: powershell, script: "Start-Process calc.exe"}
  verify: {lang: powershell, script: "Get-Process Calculator -ErrorAction SilentlyContinue | Out-String"}
  success: {type: custom}
  state_update:
    active_app: "calc"

- id: CMD_OPEN_EXPLORER
  intents: ["открой проводник", "открой папки", "explorer"]
  description_short: "Открывает Проводник."
  execute: {lang: powershell, script: "Start-Process explorer.exe"}
  verify: {lang: powershell, script: "Get-Process explorer -ErrorAction SilentlyContinue | Out-String"}
  success: {type: process_running, process_name: explorer}

- id: CMD_OPEN_APP_SEARCH
  intents: ["открой *", "запусти *", "open *", "launch *"]
  description_short: "Открывает приложение через Windows Search."
  params:
    - name: app
      from_user: true
  execute:
    lang: python
    script: |
      import time
      import pyautogui
      app = "{{app}}"
      pyautogui.press("win")
      time.sleep(0.2)
      pyautogui.typewrite(app, interval=0.02)
      time.sleep(0.1)
      pyautogui.press("enter")
      print("OK: launched", app)
  verify:
    lang: python
    script: |
      import pygetwindow as gw
      target = "{{app}}".lower()
      win = gw.getActiveWindow()
      title = (win.title if win else "").lower()
      if target in title:
        print("OK: active window contains", target)
      else:
        print("WARN: active window not matched", title)
  success:
    type: custom

# ======== FILES SAFE ========
- id: CMD_CREATE_TXT_DESKTOP
  intents: ["создай txt *", "создай текстовый файл *", "создай файл ткст *"]
  description_short: "Создаёт txt на Desktop и записывает текст."
  params:
    - name: content
      from_user: true
    - name: filename
      default: "note.txt"
  execute:
    lang: powershell
    script: |
      $desktop = [Environment]::GetFolderPath('Desktop')
      $path = Join-Path $desktop "{{filename}}"
      "{{content}}" | Set-Content -Path $path -Encoding UTF8
      Write-Host "SAVED: $path"
  verify:
    lang: powershell
    script: |
      $desktop = [Environment]::GetFolderPath('Desktop')
      $path = Join-Path $desktop "{{filename}}"
      if (Test-Path $path) { "OK" } else { exit 1 }
  success: {type: file_exists}
  state_update:
    active_file: "{{desktop}}\\{{filename}}"

- id: CMD_CREATE_DOCX_DESKTOP
  intents: ["создай ворд файл *", "создай docx *", "создай документ word *", "создай документ ворд *"]
  description_short: "Создаёт настоящий .docx на Desktop через python-docx."
  params:
    - name: content
      from_user: true
    - name: filename
      default: "document.docx"
  execute:
    lang: python
    script: |
      from pathlib import Path
      from docx import Document
      desktop = Path.home() / "Desktop"
      path = desktop / "{{filename}}"
      doc = Document()
      doc.add_paragraph("{{content}}")
      doc.save(path)
      print(f"SAVED: {path}")
  verify:
    lang: python
    script: |
      from pathlib import Path
      p = Path.home() / "Desktop" / "{{filename}}"
      print("OK" if p.exists() else "FAIL")
      if not p.exists(): raise RuntimeError("docx not found")
  success: {type: file_exists}
  state_update:
    active_file: "{{desktop}}\\{{filename}}"

# ======== BROWSER / SEARCH ========
- id: CMD_OPEN_URL
  intents: ["открой ссылку *", "открой сайт *", "перейди на *", "open url *"]
  description_short: "Открывает URL в браузере."
  params: [{name: url, from_user: true}]
  execute: {lang: powershell, script: "Start-Process \"{{url}}\""}
  verify: {lang: powershell, script: "OK"}
  success: {type: none}
  state_update:
    active_url: "{{url}}"

- id: CMD_GOOGLE_SEARCH
  intents: ["погугли *", "найди в гугле *", "google *", "поиск *", "найди * в гугле"]
  description_short: "Открывает Google поиск по запросу."
  params: [{name: query, from_user: true}]
  execute:
    lang: powershell
    script: |
      $q=[uri]::EscapeDataString("{{query}}")
      Start-Process "https://www.google.com/search?q=$q"
  verify: {lang: powershell, script: "OK"}
  success: {type: none}

- id: CMD_YOUTUBE_OPEN
  intents: ["открой ютуб", "youtube", "youtube.com", "открой youtube", "ютуб открой"]
  description_short: "Открывает YouTube."
  execute: {lang: powershell, script: "Start-Process \"https://www.youtube.com/\""}
  verify: {lang: powershell, script: "OK"}
  success: {type: none}
  state_update:
    active_url: "https://www.youtube.com/"

- id: CMD_YOUTUBE_SEARCH
  intents:
    [
      "найди на ютубе *",
      "поиск ютуб *",
      "youtube search *",
      "открой ютуб и найди *",
      "найди видео * на ютубе",
      "ютуб найди *",
    ]
  description_short: "Открывает результаты поиска YouTube."
  params: [{name: query, from_user: true}]
  execute:
    lang: powershell
    script: |
      $q=[uri]::EscapeDataString("{{query}}")
      Start-Process "https://www.youtube.com/results?search_query=$q"
  verify: {lang: powershell, script: "OK"}
  success: {type: none}
  state_update:
    active_url: "https://www.youtube.com/results?search_query={{query}}"

- id: CMD_BROWSER_NEW_TAB
  intents: ["новая вкладка", "открой новую вкладку", "ctrl t"]
  description_short: "Ctrl+T новая вкладка в браузере."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","t")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_BROWSER_CLOSE_TAB
  intents: ["закрой вкладку", "ctrl w", "close tab"]
  description_short: "Ctrl+W закрывает вкладку."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","w")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_BROWSER_REOPEN_TAB
  intents: ["верни вкладку", "открой закрытую вкладку", "ctrl shift t"]
  description_short: "Ctrl+Shift+T вернуть закрытую вкладку."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","shift","t")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_BROWSER_ADDRESS_BAR
  intents: ["в адресную строку", "открой адресную строку", "ctrl l"]
  description_short: "Ctrl+L фокус на адресную строку."
  execute:
    lang: python
    script: |
      import pyautogui
      pyautogui.hotkey("ctrl","l")
      print("OK")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

# ======== SMART “FIND ON PAGE” ========
- id: CMD_FIND_ON_PAGE
  intents: ["найди на странице *", "ctrl f *", "поиск по странице *"]
  description_short: "Ctrl+F поиск по странице + ввод текста."
  params: [{name: text, from_user: true}]
  execute:
    lang: python
    script: |
      import time
      import pyautogui
      text="{{text}}"
      pyautogui.hotkey("ctrl","f")
      time.sleep(0.1)
      pyautogui.typewrite(text, interval=0.01)
      pyautogui.press("enter")
      print("OK: find on page")
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

# ======== YOUTUBE HOTKEYS ========
- id: CMD_YT_PLAY_PAUSE
  intents: ["пауза", "поставь на паузу", "продолжи", "play pause"]
  description_short: "YouTube: K пауза/плей."
  execute: {lang: python, script: "import pyautogui; pyautogui.press('k'); print('OK')"}
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_YT_FORWARD_10
  intents: ["вперед 10", "перемотай вперед", "forward 10"]
  description_short: "YouTube: L вперед 10 сек."
  execute: {lang: python, script: "import pyautogui; pyautogui.press('l'); print('OK')"}
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_YT_BACK_10
  intents: ["назад 10", "перемотай назад", "back 10"]
  description_short: "YouTube: J назад 10 сек."
  execute: {lang: python, script: "import pyautogui; pyautogui.press('j'); print('OK')"}
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_YT_MUTE
  intents: ["выключи звук", "mute", "без звука"]
  description_short: "YouTube: M mute."
  execute: {lang: python, script: "import pyautogui; pyautogui.press('m'); print('OK')"}
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

- id: CMD_YT_FULLSCREEN
  intents: ["полный экран", "fullscreen", "фуллскрин"]
  description_short: "YouTube: F fullscreen."
  execute: {lang: python, script: "import pyautogui; pyautogui.press('f'); print('OK')"}
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

# ======== BULK / LOOP HELPERS ========
- id: CMD_PRESS_CTRL_W_TIMES
  intents: ["закрой * вкладок", "закрой вкладки * раз", "ctrl w * раз"]
  description_short: "Нажимает Ctrl+W N раз."
  params: [{name: times, from_user: true}]
  execute:
    lang: python
    script: |
      import time, pyautogui
      n=int("{{times}}")
      for i in range(n):
        pyautogui.hotkey("ctrl","w")
        time.sleep(0.15)
      print("OK: closed tabs", n)
  verify: {lang: python, script: "print('OK')"}
  success: {type: custom}

# ----------------------------------------
# Конец библиотеки (можно дополнять дальше)
# ----------------------------------------
